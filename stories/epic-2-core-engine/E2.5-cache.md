# E2.5: Cache Layer

**Epic:** E2 - Core Scraping Engine
**Story ID:** E2.5
**Story Points:** 3
**Priority:** P0 (Critical)
**Type:** Feature
**Status:** ⏸️ Blocked

---

## User Story

**As a** developer
**I want to** check cache before scraping
**So that** repeat queries within TTL are instant

---

## Acceptance Criteria

- [ ] Implement `src/storage/cache.py` with `CacheManager` class
- [ ] Method: `get_or_fetch(source_name, scraper_func, ttl_hours=6)`
  - Check DB for cached events (`get_cached_events()`)
  - If found: Return cached (log cache HIT)
  - If not found: Call scraper, store, return (log cache MISS)
- [ ] Log cache statistics (hit rate, age of data)
- [ ] Configuration: TTL from env var (`CACHE_TTL_HOURS`)
- [ ] Method: `invalidate_cache(source_name)` for testing
- [ ] Unit test with mocked DB and scraper

---

## Cache Logic

```python
def get_or_fetch(source_name, scraper_func, ttl_hours=6):
    cached = self.db.get_cached_events(source_name, ttl_hours)
    if cached:
        age = datetime.now() - cached[0]['scraped_at']
        logger.info(f"Cache HIT for {source_name}: {len(cached)} events (age: {age})")
        return cached

    logger.info(f"Cache MISS for {source_name}, scraping...")
    events = scraper_func()
    self.db.upsert_events(events)
    return events
```

---

## Dependencies

**Depends on:** E2.4 (Supabase Integration)
**Blocks:** E2.6 (Orchestrator)

---

## Definition of Done

- [ ] Cache hit returns existing data
- [ ] Cache miss triggers scrape + store
- [ ] TTL configurable via .env
- [ ] Unit tests pass
- [ ] Logging shows cache hit/miss clearly

---

## Technical Notes

Default TTL: 6 hours (configurable)
Environment variable: `CACHE_TTL_HOURS=6`

Cache invalidation useful for testing and forced refresh scenarios.

---

**Created:** 2025-10-07
**Last Updated:** 2025-10-07
